Layer 2s are not the end... The best place to begin understanding why is, unsurprisingly, [Vitalik's blog](https://vitalik.ca/general/2022/09/17/layer_3.html). Most importantly, "sophisticated" approaches to L3s

> are not just stacking the same thing on top of itself, they're assigning the second layer and the third layer **different purposes**.

>[There are] three visions of what "L3s" are for:

1.  **L2 is for scaling, L3 is for customized functionality, for example privacy.** In this vision there is no attempt to provide "scalability squared"; rather, there is one layer of the stack that helps applications scale, and then separate layers for customized functionality needs of different use cases.
2.  **L2 is for general-purpose scaling, L3 is for customized scaling**. Customized scaling might come in different forms: specialized applications that use something other than the EVM to do their computation, rollups whose data compression is optimized around data formats for specific applications (including separating "data" from "proofs" and replacing proofs with a single SNARK per block entirely), etc.
3.  **L2 is for trustless scaling (rollups), L3 is for weakly-trusted scaling (validiums)**. [Validiums](https://ethereum.org/en/developers/docs/scaling/validium/) are systems that use SNARKs to verify computation, but leave data availability up to a trusted third party or committee. Validiums are in my view highly underrated: in particular, many "enterprise blockchain" applications may well actually be best served by a centralized server that runs a validium prover and regularly commits hashes to chain. Validiums have a lower grade of security than rollups, but can be vastly cheaper.

Vitalik also makes the fascinating point that L3s can be done in a potentially simpler (and similarly gas-cost efficient way) through leveraging ERC 4337 aggregate verfification and recursive SNARKs or STARKs, as is alrady happening with S

## Further Resources

[AppChains are coming](https://www.youtube.com/watch?v=Zw_tWvg7Ph4). This talk highlights how some of the drawbacks of "App Chains" as they have been implemented so far (in Cosmos, for instance) can be largely solved with Validity Rollups like Starknet. The properties of such Validity rollups mean that you can maintain security, still get a large degree of composability, and make it almost as simple to deploy your own App Chian as it currently is to deploy a contract on an existing Layer 1 or 2 network.

The difference between Validity Rollups and Cosmos is instructive here. Validators on an app chain in Cosmos can still collude and thereby degrade the security properties of that specific chain, whereas Validity Rollups make sure that each app chain inherits the underlying security of the layer 1, because the results of any computation are always povably correct. We recommend Eli Ben-Sasson's talk, which is described in [[Infra Resources]] in more detail.

Given that App Chains are coming in many different forms across ecosystems, it's important that we understand some of the more cutting edge cryptographic work on this, for which we turn to [Gideon Kaempfer](https://www.youtube.com/watch?v=5VBP6-6A7eA), in order to understand not just the roots of prover-verifier cryptographic systems, but how they might be built **recursively**. "Recursive" meeans that we can prove the verification of a proof. Which is interesting, because we can prove a bunch of things, and the prove the verification of all those proofs simultaneously, so you do all sorts of things, prove the outputs to be valid, and then prove that validity across all the different verifications in a single proof.

![[recursion.png]]

